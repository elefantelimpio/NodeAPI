diff --git a/node_modules/node-restful/lib/model.js b/node_modules/node-restful/lib/model.js
index a1a3615..3d1e666 100644
--- a/node_modules/node-restful/lib/model.js
+++ b/node_modules/node-restful/lib/model.js
@@ -1,7 +1,7 @@
 var mongoose = require('mongoose'),
-    _ = require('underscore'),
-    Model = mongoose.Model,
-    handlers = require('./handlers');
+  _ = require('underscore'),
+  Model = mongoose.Model,
+  handlers = require('./handlers');
 
 exports = module.exports = model;
 
@@ -16,49 +16,50 @@ var methods = ['get', 'post', 'put', 'delete'], // All HTTP methods, PATCH not c
     'delete': 'deleted'
   },
   valid_alterables = filterable({
-      'populate': query('populate'),
-    }, {});
-  valid_filters = filterable({
-      'limit': query('limit'),
-      'skip': query('skip'),
-      'offset': query('offset'),
-      'select': query('select'),
-      'sort': query('sort'),
-    }, {
-      'equals': query('equals'),
-      'gte': query('gte'),
-      'gt': query('gt'),
-      'lt': query('lt'),
-      'lte': query('lte'),
-      'ne': query('ne'),
-      'regex': function(val, query) {
-        var regParts = val.match(/^\/(.*?)\/([gim]*)$/);
-        if (regParts) {
-          // the parsed pattern had delimiters and modifiers. handle them.
-          val = new RegExp(regParts[1], regParts[2]);
-        } else {
-          // we got pattern string without delimiters
-          val = new RegExp(val);
-        }
+    'populate': query('populate'),
+  }, {});
+valid_filters = filterable({
+  'limit': query('limit'),
+  'skip': query('skip'),
+  'offset': query('offset'),
+  'select': query('select'),
+  'sort': query('sort'),
+}, {
+    'equals': query('equals'),
+    'gte': query('gte'),
+    'gt': query('gt'),
+    'lt': query('lt'),
+    'lte': query('lte'),
+    'ne': query('ne'),
+    'exists': query('exists'),
+    'regex': function (val, query) {
+      var regParts = val.match(/^\/(.*?)\/([gim]*)$/);
+      if (regParts) {
+        // the parsed pattern had delimiters and modifiers. handle them.
+        val = new RegExp(regParts[1], regParts[2]);
+      } else {
+        // we got pattern string without delimiters
+        val = new RegExp(val);
+      }
 
-        return query.regex(val);
-      },
-      'in': query('in'),
-      'nin': query('nin'),
-    });
-  defaults = function() {
-    return {
-      routes: {},
-      allowed_methods: {
-        get: { detail: false }
-      },
-      update_options: {},
-      remove_options: {},
-      templateRoot: '',
-      shouldIncludeSchema: true,
-      shouldUseAtomicUpdate: true
-    };
+      return query.regex(val);
+    },
+    'in': query('in'),
+    'nin': query('nin'),
+  });
+defaults = function () {
+  return {
+    routes: {},
+    allowed_methods: {
+      get: { detail: false }
+    },
+    update_options: {},
+    remove_options: {},
+    templateRoot: '',
+    shouldIncludeSchema: true,
+    shouldUseAtomicUpdate: true
   };
+};
 
 /**
  * Returns the model associated with the given name or
@@ -66,26 +67,26 @@ var methods = ['get', 'post', 'put', 'delete'], // All HTTP methods, PATCH not c
  */
 function model() {
   var result = mongoose.model.apply(mongoose, arguments),
-      default_properties = defaults();
+    default_properties = defaults();
   if (1 === arguments.length) return result;
 
   for (var key in default_properties) {
-   result[key] = default_properties[key];
+    result[key] = default_properties[key];
   }
 
   return result;
 }
 
-Model.includeSchema = function(shouldIncludeSchema) {
+Model.includeSchema = function (shouldIncludeSchema) {
   this.shouldIncludeSchema = shouldIncludeSchema;
   return this;
 };
 
-Model.methods = function(newmethods) {
+Model.methods = function (newmethods) {
   var self = this,
     get = contains(newmethods, 'get');
 
-  methods.forEach(function(method) {
+  methods.forEach(function (method) {
     delete self.routes[method];
   });
 
@@ -100,7 +101,7 @@ Model.methods = function(newmethods) {
       after: (typeof get !== 'string') ? get.after : null
     });
   }
-  newmethods.forEach(function(meth) {
+  newmethods.forEach(function (meth) {
     var method = meth.method;
     if ('string' === typeof meth) {
       method = meth;
@@ -116,17 +117,17 @@ Model.methods = function(newmethods) {
   return this;
 };
 
-Model.updateOptions = function(options) {
+Model.updateOptions = function (options) {
   this['update_options'] = options;
   return this;
 };
 
-Model.removeOptions = function(options) {
+Model.removeOptions = function (options) {
   this['remove_options'] = options;
   return this;
 };
 
-Model.template = function(templatePath) {
+Model.template = function (templatePath) {
   if (templatePath.substr(-1) == '/') {
     templatePath = templatePath.substr(0, templatePath.length - 1);
   }
@@ -137,20 +138,20 @@ Model.template = function(templatePath) {
 /**
  * Adds the default routes for the HTTP methods and one to get the schema
  */
-Model.addDefaultRoutes = function() {
+Model.addDefaultRoutes = function () {
   if (this.shouldIncludeSchema) {
     this.route('schema', handlers.schema);
   }
   this.addSchemaRoutes();
 };
 
-Model.addSchemaRoutes = function() {
+Model.addSchemaRoutes = function () {
   var self = this;
-  this.schema.eachPath(function(pathName, schemaType) {
+  this.schema.eachPath(function (pathName, schemaType) {
     if (pathName.indexOf('_id') === -1 && schemaType.instance === 'ObjectID') {
       // Right now, getting nested models is the only operation supported
-      ['get'].forEach(function(method) {
-        self.route(pathName, method , {
+      ['get'].forEach(function (method) {
+        self.route(pathName, method, {
           handler: handlers[method + 'Path'].call(self, pathName),
           detail: true
         });
@@ -168,10 +169,10 @@ Model.addSchemaRoutes = function() {
  * @return {Model} for chaining
  * @api public
  */
-Model.route = function(path, method, fn) {
+Model.route = function (path, method, fn) {
   var route = getRoute(this.routes, path),
-      meths = methods, // Default to all methods
-      lastPath = path.substr(path.lastIndexOf('.') + 1);
+    meths = methods, // Default to all methods
+    lastPath = path.substr(path.lastIndexOf('.') + 1);
 
   if (2 === arguments.length) {
     fn = method;
@@ -187,21 +188,21 @@ Model.route = function(path, method, fn) {
   if (fn) {
     fn = normalizeHandler(fn);
 
-    meths.forEach(function(meth) {
+    meths.forEach(function (meth) {
       route[meth] = merge(route[meth], fn);
     });
   }
   return this;
 };
 
-Model.before = function(path, method, fn) {
+Model.before = function (path, method, fn) {
   if (2 == arguments.length) {
     arguments[1] = { before: arguments[1] };
   }
   return this.route.apply(this, arguments);
 };
 
-Model.after = function(path, method, fn) {
+Model.after = function (path, method, fn) {
   if (2 == arguments.length) {
     arguments[1] = { after: arguments[1] };
   }
@@ -218,26 +219,26 @@ Model.after = function(path, method, fn) {
  *   for (var key in routeObj) { recurse }
  * }
  */
-Model.registerRoutes = function(app, prefix, path, routeObj) {
+Model.registerRoutes = function (app, prefix, path, routeObj) {
   var self = this;
   for (var key in routeObj) {
     if (isEndpoint(routeObj, key)) {
       var route = routeObj[key];
       var routehandlers = _.isArray(route.handler) ? route.handler : [route.handler];
-      routehandlers = _.map(routehandlers, function(handler) { return handler.bind(self); });
+      routehandlers = _.map(routehandlers, function (handler) { return handler.bind(self); });
       var detailGet = !route.detail && !path && key === 'get',
-          handlerlist = route.before.concat(
-            [preprocess.bind(self)],
-            routehandlers,
-            route.after,
-            [handlers.last]
-          );
+        handlerlist = route.before.concat(
+          [preprocess.bind(self)],
+          routehandlers,
+          route.after,
+          [handlers.last]
+        );
       /**
        * TODO(baugarten): Add an enum type-thing to specify detail route, detail optional or list
        * aka prettify this
        */
       if (route.detail) {
-        app[key](prefix + '/:id([0-9a-fA-F]{0,24})' + path , handlerlist);
+        app[key](prefix + '/:id([0-9a-fA-F]{0,24})' + path, handlerlist);
       } else if (detailGet) {
         app[key](prefix + '/:id([0-9a-fA-F]{0,24}$)?', handlerlist);
       } else {
@@ -256,7 +257,7 @@ Model.registerRoutes = function(app, prefix, path, routeObj) {
  * in the model definition
  *
  */
-Model.register = function(app, url) {
+Model.register = function (app, url) {
   this.addDefaultRoutes();
   app.getDetail = app.get;
   this.registerRoutes(app, url, '', this.routes);
@@ -288,7 +289,6 @@ Model.register = function(app, url) {
   };
   this.send(route.split(/\./), req, res);
 }
-
 Model.prototype.send = function(routes, req, res, next) {
   var handler = this.routes;
   req.quer = this.filter(req.filters, req.body, req.query, this.Model.find({}));
@@ -301,11 +301,9 @@ Model.prototype.send = function(routes, req, res, next) {
     }
   });
   if ('all' in handler) handler = handler.all;
-
   if ('function' === typeof handler) {
     return handler.call(this, req, res, next);
   }
-
   handlers.respond(res, 404, handlers.respond404());
   handlers.last(req, res);
 }*/
@@ -315,7 +313,7 @@ Model.prototype.send = function(routes, req, res, next) {
  * Looks in req.body and req.query to get the filterable data
  * Filters the query based on functions in valid_filters
  */
-Model.filter = function(req, quer) {
+Model.filter = function (req, quer) {
   var detail = false; // detail route
   // filter by id
   if (req.params.id) {
@@ -323,19 +321,19 @@ Model.filter = function(req, quer) {
     detail = true
   }
 
-  [req.body, req.query, req.headers].forEach(function(alterableResponse) {
-    Object.keys(alterableResponse).filter(function(potential) {
+  [req.body, req.query, req.headers].forEach(function (alterableResponse) {
+    Object.keys(alterableResponse).filter(function (potential) {
       return valid_alterables.contains(potential, quer);
-    }).forEach(function(valid_key) {
+    }).forEach(function (valid_key) {
       query = valid_alterables.filter(valid_key, alterableResponse[valid_key], quer);
     });
   });
 
   if (!detail) {
-    [req.body, req.query, req.headers].forEach(function(filterableData) {
-      Object.keys(filterableData).filter(function(potential_filter) {
+    [req.body, req.query, req.headers].forEach(function (filterableData) {
+      Object.keys(filterableData).filter(function (potential_filter) {
         return valid_filters.contains(potential_filter, quer);
-      }).forEach(function(valid_key) {
+      }).forEach(function (valid_key) {
         quer = valid_filters.filter(valid_key, filterableData[valid_key], quer);
       });
     });
@@ -357,7 +355,7 @@ function preprocess(req, res, next) {
 }
 
 function query(key) {
-  return function(val, query) {
+  return function (val, query) {
     return query[key](val);
   };
 }
@@ -401,7 +399,7 @@ function getRoute(routes, path) {
   if (endpoints.indexOf(path[path.length - 1]) > -1) {
     path.splice(path.length - 1, 1);
   }
-  path.forEach(function(sub, i) {
+  path.forEach(function (sub, i) {
     if (!routes[sub]) routes[sub] = {};
     routes = routes[sub];
   });
@@ -417,10 +415,10 @@ function normalizeHandler(fn) {
       handler: fn
     };
   }
-  ['before', 'after'].forEach(function(hook) {
+  ['before', 'after'].forEach(function (hook) {
     result[hook] = fn[hook] || [];
     if (!Array.isArray(result[hook])) {
-      result[hook] = [ result[hook] ];
+      result[hook] = [result[hook]];
     }
   });
   return result;
@@ -454,7 +452,7 @@ function coerceData(filter_func, data) {
 
 function filterable(props, subfilters) {
   return {
-    filter: function(key, val, quer) {
+    filter: function (key, val, quer) {
       if (props[key]) {
         return props[key](coerceData(key, val), quer);
       }
@@ -469,11 +467,23 @@ function filterable(props, subfilters) {
 
       return subfilters[filter_func](data, quer.where(field[0]));
     },
-    contains: function(key, quer) {
+    contains: function (key, quer) {
       if (key in props) return true;
       var field = key.split('__');
       var filter_func = field[1] || 'equals';
-      return field[0] in quer.model.schema.paths && filter_func in subfilters;
+
+      var prop = field[0];
+
+      if (prop.split('.').length) {
+        var path = prop.split('.');
+        var path = quer.model.schema.paths[path[0]];
+
+        if (path && path.instance === 'Array') {
+          prop = prop.split('.')[0];
+        }
+      }
+
+      return prop in quer.model.schema.paths && filter_func in subfilters;
     }
   }
 }
\ No newline at end of file
